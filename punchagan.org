#+STARTUP: indent

This is all the code that gets run inside the user-config function in
dotspacemacs. The sections are organized similar to the layers of Spacemacs.

* Startup
Turn on lexical binding, so that we can use it in the code that follows!
#+BEGIN_SRC emacs-lisp
;; -*- lexical-binding: t -*-
#+END_SRC

* Spacemacs layers?
** Editor
*** Use paredit bindings
#+BEGIN_SRC emacs-lisp
  (sp-use-paredit-bindings)
#+END_SRC

* Chat
** Jabber
**** Account setup
#+BEGIN_SRC emacs-lisp
  (setq jabber-account-list
        `(
          ;; Gmail
          (,(format "punchagan@gmail.com/Emacs-%s-Jabber" emacs-version)
           (:network-server . "talk.google.com")
           (:password . ,(cadr (auth-source-user-and-password "emacs-jabber")))
           (:connection-type . starttls))
          ))
#+END_SRC
**** Appearance
#+BEGIN_SRC emacs-lisp
  ;; Don't show avatars in chat windows
  (setq jabber-chat-buffer-show-avatar nil)

  ;; Jabber roster tweaks
  (setq jabber-roster-show-title nil
        jabber-roster-show-bindings nil)

  ;; make URLs clickable
  (add-hook 'jabber-chat-mode-hook 'goto-address)
#+END_SRC

**** Alerts
***** Custom notifications
Switch to the buffer when notification is clicked.

#+BEGIN_SRC emacs-lisp
  (defun pc/jabber-message-notifications (from buffer text title)
      "Show a message through the notifications.el interface"
      (let
          ((body (or (jabber-escape-xml text) " "))
           (head (jabber-escape-xml
                  (or title
                      (or jabber-notifications-message-header " ")
                      text)))
           (avatar-hash (get (jabber-jid-symbol from) 'avatar-hash))
           (on-close (lambda (id action) (unless (or (null jabber-activity-mode)
                                                     (member buffer (mapcar #'window-buffer (window-list))))
                                           (switch-to-buffer buffer)))))
        (notifications-notify
         :title title
         :body body
         :app-icon (or (and avatar-hash (jabber-avatar-find-cached avatar-hash))
                       jabber-notifications-icon)
         :app-name jabber-notifications-app
         :category "jabber.message"
         :timeout jabber-notifications-timeout
         :on-close on-close)))
#+END_SRC

***** Setup notifications
#+BEGIN_SRC emacs-lisp
  (setq jabber-alert-presence-hooks nil)

  (setq jabber-alert-message-hooks '(jabber-message-scroll pc/jabber-message-notifications))

  ;; Enable alerts when focussed out of Emacs
  (add-hook 'focus-out-hook
            (lambda () (add-hook 'jabber-alert-message-hooks #'pc/jabber-message-notifications)))

  ;; Disable alerts when focussed in Emacs
  (add-hook 'focus-in-hook
            (lambda () (remove-hook 'jabber-alert-message-hooks #'pc/jabber-message-notifications)))

#+END_SRC

**** Auto-away
#+BEGIN_SRC emacs-lisp
(add-hook 'jabber-post-connect-hooks 'jabber-autoaway-start)
#+END_SRC
**** History
#+BEGIN_SRC emacs-lisp
  (setq
   jabber-history-enabled t
   jabber-use-global-history nil
   jabber-backlog-number 40
   jabber-backlog-days 30)
#+END_SRC

**** Jabber message queue
#+BEGIN_SRC emacs-lisp
  (defconst pc/jabber-message-queue-file
    (expand-file-name ".jabber-message-queue.json" user-emacs-directory)
    "The file where jabber messages are queued")

  (defun pc/jabber-add-message-to-queue (to body)
    "Queue up messages when offline, and send on connect."
    (interactive (list
                  (read-string "message: ")))
    (let* ((from (nth 0 jabber-account-history))
           (data (append
                  (or (ignore-errors (json-read-file pc/jabber-message-queue-file)) '())
                  `(((from . ,from) (to . ,to) (body . ,body))))))

      (with-temp-buffer
        (insert (json-encode data))
        (write-file pc/jabber-message-queue-file nil))))

  (defun pc/jabber-chat-buffer-send ()
    "Send the message in the chat buffer to the queue."
    (interactive)
    (let ((body (delete-and-extract-region jabber-point-insert (point-max))))
      (funcall 'pc/jabber-add-message-to-queue jabber-chatting-with body)))

  (defun pc/jabber-flush-queue (jc)
    "Send all queued messages and empty queue."
    (ignore-errors
      (let ((data (or (ignore-errors (json-read-file pc/jabber-message-queue-file)) '())))
        ;; Send messages
        (mapcar
         (lambda (x) (let ((to (cdr (assoc 'to x)))
                           (body (cdr (assoc 'body x)))
                           (from (cdr (assoc 'from x))))
                       (when (string= from (jabber-connection-bare-jid jc))
                         (jabber-send-message jc to nil body "chat")
                         (message (format "Sent message to %s: %s" to body))
                         (setq data (delete x data)))))
         data)


        ;; Update queue file
        (with-temp-buffer
          (insert (json-encode data))
          (write-file pc/jabber-message-queue-file nil))

        ;; Restore keymap
        (mapcar
         (lambda (buffer)
           (with-current-buffer buffer
             (when (equal major-mode 'jabber-chat-mode)
               (local-set-key (kbd "RET") 'jabber-chat-buffer-send))))
         (buffer-list)))))

  (add-hook 'jabber-post-connect-hooks 'pc/jabber-flush-queue)
#+END_SRC
* Emacs
** Org
*** org-mode
**** Set org-directory
#+BEGIN_SRC emacs-lisp
  (setq org-directory "~/.life-in-plain-text/src/")
#+END_SRC
**** Open link on RET
#+BEGIN_SRC emacs-lisp
  (setq org-return-follows-link t)
#+END_SRC
**** Agenda files
Use a file to list all the agenda files, explicitly
#+BEGIN_SRC emacs-lisp
  (setq org-agenda-files
        (expand-file-name "agenda-files.org" org-directory))
#+END_SRC
**** Enable org-capture
#+BEGIN_SRC emacs-lisp
  (require 'org-capture)
#+END_SRC
**** Enable ditaa for org-babel
#+BEGIN_SRC emacs-lisp
  (add-to-list 'org-babel-load-languages '(ditaa . t))
#+END_SRC
*** org-journal
**** Set org-journal-dir inside org-directory
#+BEGIN_SRC emacs-lisp
  (setq org-journal-dir (expand-file-name "journal/" org-directory))
#+END_SRC
**** Use .org extension for journal files
- To be able to view TODO items in the agenda
- To be able to view files in Orgzly
#+BEGIN_SRC emacs-lisp
  (setq org-journal-file-format "%Y%m%d.org")
#+END_SRC
**** Template
A hack to insert a daily template
#+BEGIN_SRC emacs-lisp
  (defun pc/new-buffer-p ()
    (not (file-exists-p (buffer-file-name))))

  (defun pc/insert-journal-template ()
    (let ((template-file (expand-file-name "template.org" org-directory)))
      (when (pc/new-buffer-p)
        (save-excursion
          (goto-char (point-min))
          (insert-file-contents template-file)))))

  (add-hook 'org-journal-after-entry-create-hook #'pc/insert-journal-template)
#+END_SRC
**** Date heading format
Change the date heading format to go with the daily template
#+BEGIN_SRC emacs-lisp
  (setq org-journal-date-format "Journal notes")
#+END_SRC
**** Refile Inbox.org items
Move items in ~Inbox.org~ file to respective journal files.
- TODO items move under tasks
- NOTES move under the journal notes heading
#+BEGIN_SRC emacs-lisp

#+END_SRC
*** org-protocol
#+BEGIN_SRC emacs-lisp
  (require 'org-protocol)
#+END_SRC
*** ox-hugo
**** Export on save
#+BEGIN_SRC emacs-lisp
  (require 'ox)
  (add-hook 'after-save-hook #'org-hugo-export-subtree-to-md-after-save)
#+END_SRC
**** Capture template for new post
#+BEGIN_SRC emacs-lisp
  (defun org-hugo-new-subtree-post-capture-template ()
    "Returns `org-capture' template string for new Hugo post."
    (let* ((date (format-time-string (org-time-stamp-format :long :inactive) (org-current-time)))
           (title (read-from-minibuffer "Post Title: ")) ;Prompt to enter the post title
           (fname (org-hugo-slug title)))
      (mapconcat #'identity
                 `(
                   ,(concat "* TODO " title " :noexport:")
                   ":PROPERTIES:"
                   ,(concat ":EXPORT_FILE_NAME: " fname)
                   ,(concat ":EXPORT_DATE: " date) ;Enter current date and time
                   ":EXPORT_DESCRIPTION:"
                   ":EXPORT_HUGO_CUSTOM_FRONT_MATTER:"
                   ":END:"
                   "%?\n")          ;Place the cursor here finally
                 "\n")))

  (with-eval-after-load 'org
    (require 'org-capture nil t)
    (add-to-list 'org-capture-templates
                 '("b"
                   "Blog post for punchagan.muse-amuse.in"
                   entry
                   (file "blog-posts.org")
                   (function org-hugo-new-subtree-post-capture-template)
                   :prepend t)))
#+END_SRC
**** Helper function to copy original org sources
#+BEGIN_SRC emacs-lisp
  (defun pc/org-hugo-copy-sources ()
    "Copy the org sources to hugo content-org dir."
    (interactive)
    (let* ((info (org-export-get-environment 'hugo))
           (base-dir (plist-get info :hugo-base-dir))
           (content-dir (expand-file-name "content-org" base-dir))
           (path (expand-file-name "all-posts.org" content-dir)))

      (make-directory content-dir t)
      (copy-file (buffer-file-name) path t)
      (with-current-buffer (find-file-noselect path)
        ;; Delete all draft posts
        (save-mark-and-excursion
          (org-map-entries (lambda () (org-mark-subtree) (delete-region (point) (mark)))
                           "EXPORT_FILE_NAME<>\"\"/!+TODO|+DRAFT"
                           'file))
        (goto-char (point-min))
        (save-buffer)
        (kill-buffer))))
#+END_SRC
** General
*** confirm on quit
#+BEGIN_SRC emacs-lisp
  (setq confirm-kill-emacs 'y-or-n-p)
#+END_SRC
* Lang
** js
*** Use prettier in js buffers
#+BEGIN_SRC emacs-lisp
  ;; (remove-hook 'js2-mode-hook 'prettier-js-mode)
  ;; (remove-hook 'web-mode-hook 'prettier-js-mode)
#+END_SRC
* Email
** Setup mu4e contexts
#+BEGIN_SRC emacs-lisp
  (defun make-match-func-from-email (email)
    (lambda (msg)
      (when msg
        (mu4e-message-contact-field-matches
         msg
         :to email))))

  (setq mu4e-contexts `(
                        ,(make-mu4e-context
                          :name "muse-amuse"
                          :enter-func (lambda () (mu4e-message "Entering muse-amuse context"))
                          :leave-func (lambda () (mu4e-message "Leaving muse-amuse context"))
                          ;; we match based on the contact-fields of the message
                          :match-func (make-match-func-from-email "punchagan@muse-amuse.in")
                          :vars '((user-mail-address . "punchagan@muse-amuse.in")
                                  (user-full-name . "Puneeth Chaganti")
                                  (message-send-mail-function . message-send-mail-with-sendmail)
                                  (mu4e-reply-to-address . "punchagan@muse-amuse.in")
                                  (mu4e-sent-folder . "/muse-amuse/Sent")
                                  (mu4e-drafts-folder . "/muse-amuse/Drafts")
                                  (mu4e-trash-folder . "/muse-amuse/Trash")))
                        ,(make-mu4e-context
                          :name "Gmail"
                          :enter-func (lambda () (mu4e-message "Entering gmail context"))
                          :leave-func (lambda () (mu4e-message "Leaving gmail context"))
                          ;; we match based on the contact-fields of the message
                          :match-func (make-match-func-from-email "punchagan@gmail.com")
                          :vars '((user-mail-address . "punchagan@gmail.com")
                                  (user-full-name . "Puneeth Chaganti")
                                  (message-send-mail-function . message-send-mail-with-sendmail)
                                  (mu4e-reply-to-address . "punchagan@gmail.com")
                                  (mu4e-sent-folder . "[Gmail].Sent Mail")
                                  (mu4e-drafts-folder . "[Gmail].Drafts")
                                  (mu4e-trash-folder . "[Gmail].Trash")
                                  (smtpmail-smtp-user . "punchagan@gmail.com")
                                  (smtpmail-mail-address . "punchagan@gmail.com")
                                  (smtpmail-default-smtp-server . "smtp.gmail.com")
                                  (smtpmail-smtp-server . "smtp.gmail.com")
                                  (smtpmail-smtp-service . 587)))))
#+END_SRC
** Setup imapfilter hook
 #+BEGIN_SRC emacs-lisp
  (defun pc/imapfilter ()
    (message "Running imapfilter...")
    (with-current-buffer (get-buffer-create " *imapfilter*")
      (goto-char (point-max))
      (insert "---\n")
      (call-process "imapfilter" nil (current-buffer) nil "-v"))
    (message "Running imapfilter...done"))

  (add-hook 'mu4e-update-pre-hook 'pc/imapfilter)
#+END_SRC
* Fun
** Play music using ~mpsyt~
#+BEGIN_SRC emacs-lisp
  ;; (require 'url)
  (defun pc/short-url-at-point ()
    "Gets the short url at point.

        This function is required only because
        `thing-at-point-url-at-point' ignores urls (without a scheme)
        that don't start with www."
    (let ((bounds (thing-at-point-bounds-of-url-at-point t)))
      (when (and bounds (< (car bounds) (cdr bounds)))
        (buffer-substring-no-properties (car bounds) (cdr bounds)))))

  (defun pc/mpsyt-url (url)
    (let ((buffer (current-buffer))
          (mpsyt-proc-name "*mpsyt*"))

      ;; Start a new term with *mpsyt* if there isn't one
      (unless (get-process mpsyt-proc-name)
        (when (get-buffer mpsyt-proc-name)
          (kill-buffer (get-buffer mpsyt-proc-name)))
        (ansi-term "mpsyt" "mpsyt")
        (pc/mpsyt-set-keybindings))

      ;; Play given url in mpsyt
      (let ((mpsyt-proc (get-process mpsyt-proc-name)))
        ;; If something is already playing, stop it and play this...
        (term-send-string mpsyt-proc "\n\n\n")
        ;; We wait for a bit, since looking for the prompt seems to fail, sometimes?
        (sleep-for 1)
        (term-send-string mpsyt-proc "\n")

        ;; Actually send the command to playurl
        (term-simple-send (get-process mpsyt-proc-name)
                          (format "playurl %s" url)))

      (switch-to-buffer buffer)))

  (defun pc/mpsyt-url-at-point ()
    "Play the URL at point using mpsyt."
    (interactive)
    (let ((url (or (url-get-url-at-point) (pc/short-url-at-point))))
      (if (not url)
          (message "No URL found")
        (message (format "Playing %s with mpsyt" url))
        (pc/mpsyt-url url))))

  (defun pc/mpsyt-set-keybindings ()
    "Change key codes sent for gray keys."
    (use-local-map (copy-keymap term-raw-map))
    (local-set-key (kbd "<up>") (lambda () (interactive) (term-send-raw-string "\e[A")))
    (local-set-key (kbd "<down>") (lambda () (interactive) (term-send-raw-string "\e[B")))
    (local-set-key (kbd "<right>") (lambda () (interactive) (term-send-raw-string "\e[C")))
    (local-set-key (kbd "<left>") (lambda () (interactive) (term-send-raw-string "\e[D"))))
#+END_SRC
**** Bind it to <f8>
#+BEGIN_SRC emacs-lisp
  (bind-key "<f8>" 'pc/mpsyt-url-at-point)
#+END_SRC
* Scimax
#+BEGIN_SRC emacs-lisp
  (setq scimax-dir "~/software/random/scimax")
  (add-to-list 'load-path scimax-dir)
  (add-to-list 'load-path (expand-file-name "ob-ipython" scimax-dir))
  (require 'scimax-org-babel-ipython)
#+END_SRC
* Web Services
** Elfeed
*** Capture template
#+BEGIN_SRC emacs-lisp
  (add-to-list 'org-capture-templates
               '("L" "Elfeed url" entry (file+headline "elfeed.org" "Blogs")
                 "* [[%:link][%:description]]  %^g\n\n"))
#+END_SRC

*** Prettier elfeed
**** Fonts
#+BEGIN_SRC emacs-lisp
  (defface pc/elfeed-search-self-posts-face
    '((((class color) (background light)) (:foreground "#070"))
      (((class color) (background dark))  (:foreground "#0ff")))
    "Face used for my own posts.")

  (defface pc/elfeed-search-programming-face
    '((((class color) (background light)) (:foreground "#070"))
      (((class color) (background dark))  (:foreground "#f90")))
    "Face used for programming posts.")

  (defface pc/elfeed-search-emacs-face
    '((((class color) (background light)) (:foreground "#070"))
      (((class color) (background dark))  (:foreground "#90f")))
    "Face used for Emacs posts.")

  (defface pc/elfeed-search-data-face
      '((((class color) (background light)) (:foreground "#070"))
        (((class color) (background dark))  (:foreground "#FFEB3B")))
      "Face used for Data posts.")

  (add-to-list 'elfeed-search-face-alist '(self pc/elfeed-search-self-posts-face))
  (add-to-list 'elfeed-search-face-alist '(programming pc/elfeed-search-programming-face))
  (add-to-list 'elfeed-search-face-alist '(emacs pc/elfeed-search-emacs-face))
  (add-to-list 'elfeed-search-face-alist '(data pc/elfeed-search-data-face))
#+END_SRC
**** Fix width
#+BEGIN_SRC emacs-lisp
  (setq shr-width 80)
#+END_SRC
